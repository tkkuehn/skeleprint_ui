#! /usr/bin/env python
#
# Support module generated by PAGE version 4.8.9
# In conjunction with Tcl version 8.6
#    Feb 25, 2017 07:24:37 PM
#    Feb 25, 2017 11:35:57 PM

from __future__ import division
import os
import errno
import math
import time
from offset_uv_strategy import OffsetUvStrategy
from direct_uv_strategy import DirectUvStrategy
from strong_angle_targeter import StrongAngleTargeter
from default_angle_targeter import DefaultAngleTargeter


commands = []


def axial_travel_calc(num_start_points, layer_diameter, filament_width):
    """Calculate axial travel from one revolution to the next.

    Arguments:
    num_start_points -- number of layer start points, placed at angles
    of 2pi / start points
    layer_diameter -- layer diameter (incremented every layer)
    filament_width -- filament width (effectively stretched by the print
    angle)
    """

    # caution, this script uses angles in radians
    print_angle = math.asin(num_start_points * filament_width / layer_diameter)
    axial_travel = filament_width / math.cos(print_angle)
    return axial_travel


def angle_finder(num_start_points, circumference, filament_width):
    """Adjust the helix angle to prevent gaps between helices.

    The correction is based on a number of start points calculated using the
    user-specified angle, so that the result is as close as possible to that
    value without allowing helices to overlap.
    """

    # caution, this script uses angles in radians

    theta = math.atan(num_start_points*filament_width/circumference)

    return theta


def adjust_feed_rate(target_feed_rate, diameter, theta):
    """Calculate the feed rate that should be passed to Grbl.

    In order to have the print head move at a given target feed rate,
    the properties of the rotational axis need to be considered. Grbl
    expects to be handling a cartesian system, so it expects all
    distances to be distances, not angles. Because of this, the feed
    rate needs to be adjusted to accomplish the target feed rate. See
    page 121 of Tristan's lab book for more information.

    Required arguments:
    target_feed_rate -- desired speed of print head relative to mandrel
    diameter -- diameter of the current layer
    theta -- target angle
    """

    new_feed_rate = (target_feed_rate
                     * (math.pow(math.sin(theta), 2)
                        + math.pow(10.0
                                   / diameter
                                   / math.pi
                                   * math.cos(theta), 2)))

    return new_feed_rate


def init_layer(feedrate, current_layer, printbed_diameter, filament_width_og,
               layer_diameter):
    """Initialize gcode and set feedrate (movement speed of the axis)."""

    commands.append(";----------------------")
    commands.append("; layer {}".format(current_layer))
    commands.append(";----------------------")
    commands.append("G1 F{:.5f}".format(feedrate))


def end_gcode():
    """Add final g code and write file containing it."""

    commands.append(";----------------------")
    commands.append("G0 Z{:.5f}".format(20))
    commands.append("G0 X{:.5f} Y{:.5f}".format(0, 0))
    commands.append("; End g code")

    timestr = time.strftime("%y_%m_%d-%H_%M_%S")

    loc = os.path.join(os.path.expanduser("~"),
                       os.path.join('Desktop', 'gcode'))
    filename = timestr+'_skeleprint.gcode'

    if not os.path.exists(loc):
        try:
            os.makedirs(loc)
        except OSError as exc:  # Guard against race condition
            print ("Directory not found, somehow you don't have a desktop. ",
                   "Or I can't find it. ")
            if exc.errno != errno.EEXIST:
                raise

    with open(os.path.join(loc, filename), "w") as file:
        file.write("\n".join(commands))


def tpg(axial_travel, filament_width_og, printbed_diameter, final_diameter,
        helix_angle, smear_factor, flow_rate, uv_offset, use_strong_pattern):
    """Generate g-code for printing cylinders at various angles.

    Required params:
        axial_travel - total length of print (ex. 200)
        filament_width_og - width of filament (0.1)
        print_radius - total radius of print (10)
        printbed_diameter - diameter of the print bed (10)
        final_diameter - target print diameter
        helix_angle - angle of the helix printed (0 - 90)
        smear_factor - how much the subsequent layer is smeared (0 - 1)
        flow_rate - calculated flow rate in cm^3 / s
        uv_offset - axial distance between UV spot and needle tip

    all units are in mm and degrees
    """

    del commands[:]

    if (uv_offset <= 0):
        strategy = DirectUvStrategy()
    else:
        strategy = OffsetUvStrategy(uv_offset)

    if (use_strong_pattern):
        targeter = StrongAngleTargeter(helix_angle)
    else:
        targeter = DefaultAngleTargeter(helix_angle)

    commands.append(";PARAMETERS")
    commands.append(";filament_width={}".format(filament_width_og))
    commands.append(";axial_travel={}".format(axial_travel))
    commands.append(";printbed_diameter={}".format(printbed_diameter))
    commands.append(";final_diameter={}".format(final_diameter))
    commands.append(";flowrate={}".format(flow_rate))

    smear_factor = smear_factor * 0.01
    print "smear factor", smear_factor

    layer_height = (math.pi / 4.0 * filament_width_og) * smear_factor
    print "layer height:", layer_height

    # find the number of layers needed to print the chosen final diameter
    layers = (((final_diameter - printbed_diameter) * 0.5)
              / layer_height)

    if (layers < 1):
        layers = 1.0

    # need a whole number of layers
    if (layers % layer_height != 0):
        layers = math.floor(layers)
        print "The print diameter you've set is not symmetrical and has \
been rounded to {} mm, with {} layers".format(
                       printbed_diameter + (2 * layer_height * layers), layers)

    print "layers:", layers
    commands.append(";layers={}".format(layers))
    commands.append(";helix_angle={}".format(helix_angle))

    current_layer = 0

    # set defaults: absolute position, mm, stop all movements
    commands.append("G0 G54 G17 G21 G90 G94 M9 M5 T0 F0.0 S0")
    commands.append("G10 P0 L20 X0 Y0 Z0")

    while (current_layer < layers):
        print "layer:", current_layer

        layer_diameter = (printbed_diameter
                          + (current_layer * layer_height))
        print "layer diameter", layer_diameter

        circumference = math.pi * layer_diameter
        print "circumference", circumference

        helix_angle_rad = math.radians(
            targeter.get_layer_target_angle(current_layer))

        # Angles below this will cause smearing as a helix overlaps itself
        min_angle = math.atan(
                filament_width_og / (math.pi * printbed_diameter))
        print "min angle", min_angle

        # no helix can be printed with an angle outside this range
        if (helix_angle_rad <= min_angle):
            theta = min_angle
        elif (helix_angle_rad >= math.radians(90)):
            theta = math.radians(90)
        else:
            theta = helix_angle_rad

        print "target angle:", math.degrees(theta)

        # distance traveled in the axial direction with every rotation
        # can also be thought of as the pitch of each helix
        x_move_per_rev = circumference * math.tan(theta)

        # some strategies restrict the set of valid target angles
        x_move_per_rev = strategy.adjust_target(x_move_per_rev)
        theta = math.atan(x_move_per_rev / circumference)
        print "target angle update:", math.degrees(theta)

        # need to adjust the angle to perfectly cover the mandrel
        # find the arc length of one section of filament along the rot axis
        filament_width_rot = filament_width_og / math.sin(helix_angle_rad)
        # find the number of start points closest to covering the mandrel
        n = math.floor(circumference / filament_width_rot)
        # adjust the pitch and angle according to the closest number of
        # start points
        filament_width_rot = circumference / n
        theta = math.asin(filament_width_og / filament_width_rot)
        x_move_per_rev = circumference * math.tan(theta)
        print "final angle:", math.degrees(theta)
        print "final pitch:", x_move_per_rev

        # filament width along the axial axis
        filament_width_ax = filament_width_og / math.cos(theta)
        print "filament width update:", filament_width_ax

        # number of start points is simply the number of helices that
        # can fit side by side
        print "number of start points: ", n

        x2 = axial_travel - filament_width_og  # adjusted for endpoint

        y = axial_travel / x_move_per_rev
        print "revs per winding:", y

        # 60000 mm^3 * s / (cm^3 * min)
        target_feed_rate = ((flow_rate * 60000.0)
                            / filament_width_og
                            / layer_height)
        print "target feed rate:", target_feed_rate

        feedrate = adjust_feed_rate(
            target_feed_rate, layer_diameter, theta)
        print "Grbl feed rate:", feedrate

        init_layer(feedrate, current_layer, printbed_diameter,
                   filament_width_og, layer_diameter)
        commands.extend(strategy.generate_layer_gcode(
            current_layer,
            filament_width_ax,
            x2,
            y,
            n,
            layer_height,
            targeter.get_layer_direction_modifier(current_layer)))
        current_layer += 1

    # Step 6: Complete print
    end_gcode()


if __name__ == '__main__':
    import tpg_gui
    tpg_gui.vp_start_gui()
